---
id: extend_input_type
title: Extending an input type
sidebar_label: Extending an input type
---
<small>Available in GraphQLite 4.0+</small>

<div class="alert alert-info">If you are not familiar with the <code>@Factory</code> tag, <a href="input-types">read first the "input types" guide</a>.</div>

Fields exposed in a GraphQL input type do not need to be all part of the factory method.

Just like with output type (that can be [extended using the `ExtendType` annotation](extend_type.md)), you can extend/modify
an input type using the `@Decorate` annotation.

Use the `@Decorate` annotation to add additional fields to an input type that is already declared by a `@Factory` annotation,
or to modify the returned object.

<div class="alert alert-info">
    The <code>@Decorate</code> annotation is very useful in scenarios where you cannot touch the <code>@Factory</code> method.
    This can happen if the <code>@Factory</code> method is defined in a third-party library or if the <code>@Factory</code> method is part
    of auto-generated code.
</div>

Let's assume you have a `Filter` class used as an input type. You most certainly have a `@Factory` to create the input type. 

```
class MyFactory
{
    /**
     * @Factory()
     */
    public function createFilter(string $name): Filter
    {
        // Let's assume you have a flexible 'Filter' class that can accept any kind of filter
        $filter = new Filter();
        $filter->addFilter('name', $name);
        return $filter;
    }
}
```

Assuming you **cannot** modify the code of this factory, you can still modify the GraphQL input type generated by
adding a "decorator" around the factory. 

```
class MyDecorator
{
    /**
     * @Decorate(inputTypeName="FilterInput")
     */
    public function addTypeFilter(Filter $filter, string $type): Filter
    {
        $filter->addFilter('type', $type);
        return $filter;
    }
}
```

In the example above, the "Filter" input type is modified. We add an additional "type" field to the input type.

A few things to notice:

- The decorator takes the object generated by the factory as first argument
- The decorator MUST return an object of the same type (or a sub-type)
- The decorator CAN contain additional parameters. They will be added to the fields of the GraphQL input type.
- The `@Decorate` annotation must contain a `inputTypeName` attribute that contains the name of the GraphQL input type
  that is decorated. If you did not specify this name in the `@Factory` annotation, this is by default the name of the
  PHP class + "Input" (for instance: "Filter" => "FilterInput")


<div class="alert alert-warning"><strong>Heads up!</strong> The <code>MyDecorator</code> class must exist in the container of your 
application and the container identifier MUST be the fully qualified class name.<br/><br/>
If you are using the Symfony bundle (or a framework with autowiring like Laravel), this 
is usually not an issue as the container will automatically create the controller entry if you do not explicitly 
declare it.</div> 
